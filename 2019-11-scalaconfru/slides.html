# Magic of integrations
## <span class="pclr">ecosystem</span> better than any framework


<div>
    <small>Wojtek Pitu≈Ça @ Sony Electronics</small>
    <small>//</small>
    <small><a href="https://twitter.com/Krever01">@Krever01</a></small>
    <br>
    <small><a href="http://w.pitula.me/presentations">w.pitula.me/presentations</small>
</div>

----

## We all love <span class="pclr">frameworks</span>

Don't we?

++++

## frameworks are <span class="pclr">easy</span>

To use.

++++

## frameworks are <span class="pclr">hard</span>

To understand and compose.

++++

## Can we do <span class="pclr">better</span>?

Libraries maybe?

++++

## Composing <span class="pclr">libraries</span> into a <span class="pclr">stack</span> is hard

Most of the times.

++++

## But does it <span class="pclr">have to</span> be?

----

## Let's create an <span class="pclr">APP</span>

For taking notes.

++++

## We'll start with a <span class="pclr">note</span>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code data-trim data-noescape>
case class Note(title: String, text: String)
</code></pre>
</div>

++++

## Note can ba <span class="pclr">saved</span>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code data-trim data-noescape>
def save(note: Note): IO[Unit]
</code></pre>
</div>

++++

## Notes can ba <span class="pclr">retrived</span>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code data-trim data-noescape>
def getAll(): IO[List[Note]]
</code></pre>
</div>


----

## How to <span class="pclr">expose</span> it?

REST, obviously.

++++

## Like <span class="pclr">this</span>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code data-trim data-noescape>
POST /notes
</code></pre>
</div>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code data-trim data-noescape>
GET /notes
</code></pre>
</div>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code data-trim data-noescape>
{ "title": "my title", "text": "my text"}
</code></pre>
</div>

++++

## First hard <span class="pclr">choice</span>

HTTP server.

----

### Meet
# <span class="pclr">Http4s</span>

++++

## Http is <span class="pclr">functional</span>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code class="scala" data-trim data-noescape>
type HttpRoutes[F[_]] = HttpRequest[F] => F[Option[HttpResponse[F]]]
</code></pre>
</div>

++++

## Back to our <span class="pclr">API</span>

++++

<small style="line-height: 0.5em"><h4>Back to our <span class="pclr">API</span></h4></small>

## That's its <span class="pclr">shape</span>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code class="scala" data-trim data-noescape>
trait NotesController[F[_]] {
  def saveNote: HttpRoutes[F]
  def getNotes: HttpRoutes[F]
}
</code></pre>
</div>

++++

<small style="line-height: 0.5em"><h4>Back to our <span class="pclr">API</span></h4></small>

## And that's how we <span class="pclr">use it</span>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code class="scala" data-trim data-noescape>
  def startApp\[F\[_]: ConcurrentEffect: Timer]
    (controller: NotesController[F]): F[ExitCode] = {
    val services      = controller.getNotes <+> controller.saveNote
    val httpApp       = Router("/" -> services).orNotFound
    val serverBuilder = BlazeServerBuilder[F]
        .bindHttp(8080, "localhost")
        .withHttpApp(httpApp)
    serverBuilder.serve.compile.drain
      .as(ExitCode.Success)
  }
</code></pre>
</div>


++++

<small style="line-height: 0.5em"><h4>Back to our <span class="pclr">API</span></h4></small>

## We also need an <span class="pclr">implementation</span>

<div style="text-align: center">
<pre style="display: inline-block; width: unset"><code class="scala" data-trim data-noescape>
class DummyNotesController[F[_]: Sync] extends NotesController[F] {
  val dsl = Http4sDsl[F]
  import dsl\._
  override def saveNote = HttpRoutes.of[F] {
    case POST -> Root / "notes" => Ok("Hello")
  }
  override def getNotes = HttpRoutes.of[F] {
    case GET -> Root / "notes" => Ok("World")
  }
}
</code></pre>
</div>

----

So you want to creat an app
a TODO app
And you know what a function is.

Lets start simple
http4s
A function
HttpRequest => HttpResponse

post your note
and get your notes

but the serialization!
circe

does http4s know about circe?
sure it does!
http4s-circe

lets save your notes
doobie

but isnt writing raw sql a little old-fashioned?
quill!

does quill know about doobie?
sure it does!
quill-doobie

Maybe json in db?
doobie-postgres-circe

Lets complicate this a little
and parse links out of text
atto!

write a parser for links
parser is a monad

parse as user types
atto-fs2
stream can be pure

lets refined it!
ensure title is not empty
refined!

but other libs don't now `Refined`

how about api?
circe-refined!

how about db?
doobie-refined!

lets write console client
decline!
decline-refined
decline-enumeratum

lets move the linksparser to fronted

and call our backend
sttp
cats-effect & fs2

you know what, I heard grpc is great, lets use it
fs2-grpc

on the other hadn grpc is so 2000, we should use kafka!
fs2-kafka


cats
cats-effect
monix/zio/ce

fs2

refined
enumeratum
fuuid

scalacache
cats-retry
upperbound

decline
decline-refined
decline-enumeratum

maybe we could share the rest definitions?
endpoints/tapir
integrated with http4s, sttp and more


atto
scodec, scodec-stream
circe

sttp
http4s
tapir/endpoints

doobie
quill

fs2-kafka
fs2-grpc






